name: Supabase Migration CI (phased)

concurrency:
  group: supabase-migrations-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches: [ main ]
    paths:
      - 'supabase/migrations/**'
      - 'supabase/config.toml'
      - '.github/workflows/supabase-migration-ci-phased.yml'
  workflow_dispatch:
    inputs:
      phase:
        description: "Which phase to run (ignored if only one migration file is present)"
        required: true
        default: all
        type: choice
        options:
          - all
          - tables
          - foreign_keys
          - indexes
          - views_functions
          - triggers_policies

jobs:
  migrate-phased:
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
      SUPABASE_PROJECT_ID: ${{ secrets.SUPABASE_PROJECT_ID }}
      SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
      # Quiet CLI; fail fast on locks
      DEBUG: ""
      SUPABASE_DB_DEBUG: "0"
      SUPABASE_LOG_LEVEL: "warn"
      PGOPTIONS: -c lock_timeout=5s -c statement_timeout=20min -c idle_in_transaction_session_timeout=1min
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Verify required secrets
        run: |
          set -euo pipefail
          [ -n "${SUPABASE_ACCESS_TOKEN:-}" ] || { echo "❌ SUPABASE_ACCESS_TOKEN is not set"; exit 1; }
          [ -n "${SUPABASE_PROJECT_ID:-}" ]   || { echo "❌ SUPABASE_PROJECT_ID is not set"; exit 1; }
          [ -n "${SUPABASE_DB_PASSWORD:-}" ]  || { echo "❌ SUPABASE_DB_PASSWORD is not set (Dashboard → Project Settings → Database password)"; exit 1; }
          echo "✅ Secrets present"

      - name: Link to Supabase project (non-interactive)
        run: supabase link --project-ref "$SUPABASE_PROJECT_ID" --password "$SUPABASE_DB_PASSWORD"

      - name: Detect migration files
        id: detect
        shell: bash
        run: |
          set -euo pipefail
          shopt -s globstar nullglob
          mapfile -t SQLS < <(find supabase/migrations -type f -name '*.sql' | sort)
          echo "Found ${#SQLS[@]} SQL file(s):"
          printf ' - %s\n' "${SQLS[@]}" || true

          if [ ${#SQLS[@]} -eq 0 ]; then
            echo "❌ No .sql files found under supabase/migrations"; exit 1;
          elif [ ${#SQLS[@]} -eq 1 ]; then
            echo "SINGLE_MODE=true" >> "$GITHUB_ENV"
            echo "SINGLE_FILE=${SQLS[0]}" >> "$GITHUB_ENV"
          else
            echo "SINGLE_MODE=false" >> "$GITHUB_ENV"
          fi

      - name: Apply single migration (no phase filtering)
        if: env.SINGLE_MODE == 'true'
        shell: bash
        run: |
          set -euo pipefail
          echo "Applying single migration file: $SINGLE_FILE"
          mkdir -p /tmp/single-work/supabase/migrations
          cp supabase/config.toml /tmp/single-work/supabase/config.toml
          cp "$SINGLE_FILE" /tmp/single-work/supabase/migrations/
          echo "::group::supabase db push (single-file)"
          if ! supabase db push --workdir /tmp/single-work > push-all.log 2>&1; then
            tail -n 200 push-all.log || true
            echo "::endgroup::"
            exit 1
          fi
          echo "::endgroup::"

      - name: Set PHASE env (for multi-file case)
        if: env.SINGLE_MODE != 'true'
        run: echo "PHASE=${{ github.event_name == 'workflow_dispatch' && inputs.phase || 'all' }}" >> $GITHUB_ENV

      - name: Stage all SQLs (multi-file case)
        if: env.SINGLE_MODE != 'true'
        shell: bash
        run: |
          set -euo pipefail
          shopt -s globstar nullglob
          mkdir -p /tmp/all
          for f in $(find supabase/migrations -type f -name '*.sql' | sort); do
            base="$(basename "$f")"
            hash="$(echo -n "$f" | sha1sum | cut -c1-8)"
            cp "$f" "/tmp/all/${hash}__${base}"
          done
          echo "Staged files:"
          ls -1 /tmp/all || true

      - name: Apply 01 tables
        if: env.SINGLE_MODE != 'true' && (env.PHASE == 'all' || env.PHASE == 'tables')
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p /tmp/phase-01/supabase/migrations
          cp supabase/config.toml /tmp/phase-01/supabase/config.toml
          shopt -s nullglob
          # Name-based first
          mapfile -t match < <(ls /tmp/all/*-01_*.sql 2>/dev/null || true)
          # Content-based fallback
          if [ ${#match[@]} -eq 0 ]; then
            while IFS= read -r -d '' f; do
              if grep -qiE '(^|[^A-Z])CREATE[[:space:]]+TABLE|PRIMARY[[:space:]]+KEY|CREATE[[:space:]]+TYPE|CREATE[[:space:]]+SCHEMA' "$f"; then
                match+=("$f")
              fi
            done < <(find /tmp/all -type f -name "*.sql" -print0)
            echo "ℹ️ Using content-based detection for phase 01."
          fi
          if [ ${#match[@]} -eq 0 ]; then
            echo "ℹ️ Phase 01: no matching files. Skipping."
          else
            printf "Phase 01 files (%d):\n" "${#match[@]}"; printf " - %s\n" "${match[@]}"
            cp "${match[@]}" /tmp/phase-01/supabase/migrations/
            echo "::group::supabase db push (01)"
            if ! supabase db push --workdir /tmp/phase-01 > push-01.log 2>&1; then
              tail -n 200 push-01.log || true
              echo "::endgroup::"
              exit 1
            fi
            echo "::endgroup::"
          fi

      - name: Apply 02 foreign keys
        if: env.SINGLE_MODE != 'true' && (env.PHASE == 'all' || env.PHASE == 'foreign_keys')
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p /tmp/phase-02/supabase/migrations
          cp supabase/config.toml /tmp/phase-02/supabase/config.toml
          shopt -s nullglob
          mapfile -t match < <(ls /tmp/all/*-02_*.sql 2>/dev/null || true)
          if [ ${#match[@]} -eq 0 ]; then
            while IFS= read -r -d '' f; do
              if grep -qiE 'ALTER[[:space:]]+TABLE.*FOREIGN[[:space:]]+KEY' "$f"; then
                match+=("$f")
              fi
            done < <(find /tmp/all -type f -name "*.sql" -print0)
            echo "ℹ️ Using content-based detection for phase 02."
          fi
          if [ ${#match[@]} -eq 0 ]; then
            echo "ℹ️ Phase 02: no matching files. Skipping."
          else
            printf "Phase 02 files (%d):\n" "${#match[@]}"; printf " - %s\n" "${match[@]}"
            cp "${match[@]}" /tmp/phase-02/supabase/migrations/
            echo "::group::supabase db push (02)"
            if ! supabase db push --workdir /tmp/phase-02 > push-02.log 2>&1; then
              tail -n 200 push-02.log || true
              echo "::endgroup::"
              exit 1
            fi
            echo "::endgroup::"
          fi

      - name: Apply 03 indexes
        if: env.SINGLE_MODE != 'true' && (env.PHASE == 'all' || env.PHASE == 'indexes')
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p /tmp/phase-03/supabase/migrations
          cp supabase/config.toml /tmp/phase-03/supabase/config.toml
          shopt -s nullglob
          mapfile -t match < <(ls /tmp/all/*-03_*.sql 2>/dev/null || true)
          if [ ${#match[@]} -eq 0 ]; then
            while IFS= read -r -d '' f; do
              if grep -qiE 'CREATE[[:space:]]+INDEX' "$f"; then
                match+=("$f")
              fi
            done < <(find /tmp/all -type f -name "*.sql" -print0)
            echo "ℹ️ Using content-based detection for phase 03."
          fi
          if [ ${#match[@]} -eq 0 ]; then
            echo "ℹ️ Phase 03: no matching files. Skipping."
          else
            printf "Phase 03 files (%d):\n" "${#match[@]}"; printf " - %s\n" "${match[@]}"
            cp "${match[@]}" /tmp/phase-03/supabase/migrations/
            echo "::group::supabase db push (03)"
            if ! supabase db push --workdir /tmp/phase-03 > push-03.log 2>&1; then
              tail -n 200 push-03.log || true
              echo "::endgroup::"
              exit 1
            fi
            echo "::endgroup::"
          fi

      - name: Apply 04 views & functions
        if: env.SINGLE_MODE != 'true' && (env.PHASE == 'all' || env.PHASE == 'views_functions')
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p /tmp/phase-04/supabase/migrations
          cp supabase/config.toml /tmp/phase-04/supabase/config.toml
          shopt -s nullglob
          mapfile -t match < <(ls /tmp/all/*-04_*.sql 2>/dev/null || true)
          if [ ${#match[@]} -eq 0 ]; then
            while IFS= read -r -d '' f; do
              if grep -qiE 'CREATE[[:space:]]+(OR[[:space:]]+REPLACE[[:space:]]+)?VIEW|CREATE[[:space:]]+FUNCTION|CREATE[[:space:]]+PROCEDURE' "$f"; then
                match+=("$f")
              fi
            done < <(find /tmp/all -type f -name "*.sql" -print0)
            echo "ℹ️ Using content-based detection for phase 04."
          fi
          if [ ${#match[@]} -eq 0 ]; then
            echo "ℹ️ Phase 04: no matching files. Skipping."
          else
            printf "Phase 04 files (%d):\n" "${#match[@]}"; printf " - %s\n" "${match[@]}"
            cp "${match[@]}" /tmp/phase-04/supabase/migrations/
            echo "::group::supabase db push (04)"
            if ! supabase db push --workdir /tmp/phase-04 > push-04.log 2>&1; then
              tail -n 200 push-04.log || true
              echo "::endgroup::"
              exit 1
            fi
            echo "::endgroup::"
          fi

      - name: Apply 05 triggers & policies
        if: env.SINGLE_MODE != 'true' && (env.PHASE == 'all' || env.PHASE == 'triggers_policies')
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p /tmp/phase-05/supabase/migrations
          cp supabase/config.toml /tmp/phase-05/supabase/config.toml
          shopt -s nullglob
          mapfile -t match < <(ls /tmp/all/*-05_*.sql 2>/dev/null || true)
          if [ ${#match[@]} -eq 0 ]; then
            while IFS= read -r -d '' f; do
              if grep -qiE 'CREATE[[:space:]]+TRIGGER|ENABLE[[:space:]]+ROW[[:space:]]+LEVEL[[:space:]]+SECURITY|CREATE[[:space:]]+POLICY|GRANT[[:space:]]' "$f"; then
                match+=("$f")
              fi
            done < <(find /tmp/all -type f -name "*.sql" -print0)
            echo "ℹ️ Using content-based detection for phase 05."
          fi
          if [ ${#match[@]} -eq 0 ]; then
            echo "ℹ️ Phase 05: no matching files. Skipping."
          else
            printf "Phase 05 files (%d):\n" "${#match[@]}"; printf " - %s\n" "${match[@]}"
            cp "${match[@]}" /tmp/phase-05/supabase/migrations/
            echo "::group::supabase db push (05)"
            if ! supabase db push --workdir /tmp/phase-05 > push-05.log 2>&1; then
              tail -n 200 push-05.log || true
              echo "::endgroup::"
              exit 1
            fi
            echo "::endgroup::"
          fi

      - name: Verify migration status
        if: success() && env.SINGLE_MODE != 'true' && env.PHASE == 'all'
        run: supabase migration list

      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: supabase-phased-logs
          path: |
            push-all.log
            push-01.log
            push-02.log
            push-03.log
            push-04.log
            push-05.log
          if-no-files-found: ignore
